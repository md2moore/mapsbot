'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _lodash = require('lodash.isstring');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isplainobject');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isregexp');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isfunction');

var _lodash8 = _interopRequireDefault(_lodash7);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _expressMiddleware = require('./express-middleware');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debug2.default)('@slack/interactive-messages:adapter');

/**
 * Transforms various forms of matching constraints to a single standard object shape
 * @param {string|RegExp|Object} matchingConstraints - the various forms of matching constraints
 * accepted
 * @returns {Object} - an object where each matching constraint is a property
 */
function formatMatchingConstraints(matchingConstraints) {
  var ret = {};
  if (!(0, _lodash4.default)(matchingConstraints)) {
    ret.callbackId = matchingConstraints;
  } else {
    ret = Object.assign({}, matchingConstraints);
  }
  return ret;
}

/**
 * Validates general properties of a matching constraints object
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @return {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 */
function validateConstraints(matchingConstraints) {
  if (matchingConstraints.callbackId && !((0, _lodash2.default)(matchingConstraints.callbackId) || (0, _lodash6.default)(matchingConstraints.callbackId))) {
    return new TypeError('Callback ID must be a string or RegExp');
  }

  return false;
}

/**
 * Validates properties of a matching constraints object specific to registering an action
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @return {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 */
function validateActionConstraints(actionConstraints) {
  if (actionConstraints.type && !(actionConstraints.type === 'select' || actionConstraints.type === 'button')) {
    return new TypeError('Type must be \'select\' or \'button\'');
  }

  // We don't need to validate unfurl, we'll just cooerce it to a boolean
  return false;
}

var SlackMessageAdapter = function () {
  /**
   * Create a message adapter.
   *
   * @param {string} verificationToken - Slack app verification token used to authenticate request
   */
  function SlackMessageAdapter(verificationToken) {
    _classCallCheck(this, SlackMessageAdapter);

    if (!(0, _lodash2.default)(verificationToken)) {
      throw new TypeError('SlackMessageAdapter needs a verification token');
    }

    this.verificationToken = verificationToken;
    this.callbacks = [];
    this.axios = _axios2.default.create({
      headers: {
        'User-Agent': (0, _util.packageIdentifier)()
      }
    });

    debug('instantiated');
  }

  /**
   * Create a server that's ready to serve requests from Slack's interactive messages.
   *
   * @param {string} [path=/slack/actions] - The path portion of the URL where the server will
   * listen for requests from Slack's interactive messages.
   */


  _createClass(SlackMessageAdapter, [{
    key: 'createServer',
    value: function createServer() {
      var _this = this;

      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/slack/actions';

      // TODO: more options (like https)
      return Promise.resolve().then(function () {
        return Promise.all([Promise.resolve(require(('express'))), Promise.resolve(require(('body-parser')))]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            express = _ref2[0],
            bodyParser = _ref2[1];

        var app = express();
        app.use(bodyParser.urlencoded({ extended: false }));
        app.post(path, _this.expressMiddleware());

        debug('server created - path: %s', path);

        return _http2.default.createServer(app);
      });
    }
  }, {
    key: 'start',
    value: function start(port) {
      var _this2 = this;

      return this.createServer().then(function (server) {
        return new Promise(function (resolve, reject) {
          _this2.server = server;
          server.on('error', reject);
          server.listen(port, function () {
            return resolve(server);
          });
          debug('server started - port: %s', port);
        });
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.server) {
          _this3.server.close(function (error) {
            delete _this3.server;
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        } else {
          reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));
        }
      });
    }
  }, {
    key: 'expressMiddleware',
    value: function expressMiddleware() {
      return (0, _expressMiddleware.createExpressMiddleware)(this);
    }
  }, {
    key: 'action',
    value: function action(matchingConstraints, callback) {
      var actionConstraints = formatMatchingConstraints(matchingConstraints);

      var error = validateConstraints(actionConstraints) || validateActionConstraints(actionConstraints);
      if (error) {
        debug('action could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(actionConstraints, callback);
    }
  }, {
    key: 'options',
    value: function options(matchingConstraints, callback) {
      var optionsConstraints = formatMatchingConstraints(matchingConstraints);

      var error = validateConstraints(optionsConstraints);
      if (error) {
        debug('options could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(optionsConstraints, callback);
    }

    /* @private */

  }, {
    key: 'registerCallback',
    value: function registerCallback(constraints, callback) {
      // Validation
      if (!(0, _lodash8.default)(callback)) {
        debug('did not register callback because its not a function');
        throw new TypeError('callback must be a function');
      }

      this.callbacks.push([constraints, callback]);

      return this;
    }
  }, {
    key: 'dispatch',
    value: function dispatch(payload) {
      var _this4 = this;

      var action = payload.actions && payload.actions[0];

      // The following result value represents "no replacement"
      var result = { status: 200 };
      // when the matcher finds a dialog submission, it will populate this value with a function
      var dialogPromiseResolve = void 0;
      var respond = function respond(message) {
        if (payload.response_url) {
          debug('sending async response');
          return _this4.axios.post(payload.response_url, message);
        } else if (dialogPromiseResolve) {
          dialogPromiseResolve(message);
        }
        return true;
      };

      this.callbacks.some(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            constraints = _ref4[0],
            fn = _ref4[1];

        // Returning false in this function continues the iteration, and returning true ends it.
        // The pattern is that we assign a value to `result` and then return true. We only desire one
        // result for the response.
        var callbackResult = void 0;

        if (constraints.callbackId) {
          if ((0, _lodash2.default)(constraints.callbackId) && payload.callback_id !== constraints.callbackId) {
            return false;
          }
          if ((0, _lodash6.default)(constraints.callbackId) && !constraints.callbackId.test(payload.callback_id)) {
            return false;
          }
        }

        if (action && constraints.type && constraints.type !== action.type) {
          return false;
        }

        if ('unfurl' in constraints && (constraints.unfurl && !payload.is_app_unfurl || !constraints.unfurl && payload.is_app_unfurl)) {
          return false;
        }

        try {
          callbackResult = fn.call(_this4, payload, respond);
        } catch (error) {
          debug('callback error: %o', error);
          result = { status: 500 };
          return true;
        }

        // Dialog submissions must be responded to in under 3 seconds
        // Setting timeout to  2.5 seconds to account for propagation
        if (payload.type === 'dialog_submission') {
          var ms = 2500;
          if (callbackResult) {
            result = { status: 200, content: (0, _util.promiseTimeout)(ms, callbackResult) };
          } else {
            result = {
              status: 200, content: new Promise(function (resolve) {
                dialogPromiseResolve = resolve;
              })
            };
          }
          return true;
        }

        if (callbackResult) {
          // Checking for Promise type
          if (typeof callbackResult.then === 'function') {
            callbackResult.then(respond).catch(function (error) {
              debug('async error for callback. callback_id: %s, error: %s', payload.callback_id, error.message);
            });
            return true;
          }
          result = { status: 200, content: callbackResult };
          return true;
        }
        return true;
      });

      return result;
    }
  }]);

  return SlackMessageAdapter;
}();

exports.default = SlackMessageAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyIsIm1hdGNoaW5nQ29uc3RyYWludHMiLCJyZXQiLCJjYWxsYmFja0lkIiwiT2JqZWN0IiwiYXNzaWduIiwidmFsaWRhdGVDb25zdHJhaW50cyIsIlR5cGVFcnJvciIsInZhbGlkYXRlQWN0aW9uQ29uc3RyYWludHMiLCJhY3Rpb25Db25zdHJhaW50cyIsInR5cGUiLCJTbGFja01lc3NhZ2VBZGFwdGVyIiwidmVyaWZpY2F0aW9uVG9rZW4iLCJjYWxsYmFja3MiLCJheGlvcyIsImNyZWF0ZSIsImhlYWRlcnMiLCJwYXRoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYWxsIiwiZXhwcmVzcyIsImJvZHlQYXJzZXIiLCJhcHAiLCJ1c2UiLCJ1cmxlbmNvZGVkIiwiZXh0ZW5kZWQiLCJwb3N0IiwiZXhwcmVzc01pZGRsZXdhcmUiLCJjcmVhdGVTZXJ2ZXIiLCJwb3J0IiwicmVqZWN0Iiwic2VydmVyIiwib24iLCJsaXN0ZW4iLCJjbG9zZSIsImVycm9yIiwiRXJyb3IiLCJjYWxsYmFjayIsIm1lc3NhZ2UiLCJyZWdpc3RlckNhbGxiYWNrIiwib3B0aW9uc0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJwdXNoIiwicGF5bG9hZCIsImFjdGlvbiIsImFjdGlvbnMiLCJyZXN1bHQiLCJzdGF0dXMiLCJkaWFsb2dQcm9taXNlUmVzb2x2ZSIsInJlc3BvbmQiLCJyZXNwb25zZV91cmwiLCJzb21lIiwiZm4iLCJjYWxsYmFja1Jlc3VsdCIsImNhbGxiYWNrX2lkIiwidGVzdCIsInVuZnVybCIsImlzX2FwcF91bmZ1cmwiLCJjYWxsIiwibXMiLCJjb250ZW50IiwiY2F0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxRQUFRLHFCQUFhLHFDQUFiLENBQWQ7O0FBRUE7Ozs7OztBQU1BLFNBQVNDLHlCQUFULENBQW1DQyxtQkFBbkMsRUFBd0Q7QUFDdEQsTUFBSUMsTUFBTSxFQUFWO0FBQ0EsTUFBSSxDQUFDLHNCQUFjRCxtQkFBZCxDQUFMLEVBQXlDO0FBQ3ZDQyxRQUFJQyxVQUFKLEdBQWlCRixtQkFBakI7QUFDRCxHQUZELE1BRU87QUFDTEMsVUFBTUUsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JKLG1CQUFsQixDQUFOO0FBQ0Q7QUFDRCxTQUFPQyxHQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNJLG1CQUFULENBQTZCTCxtQkFBN0IsRUFBa0Q7QUFDaEQsTUFBSUEsb0JBQW9CRSxVQUFwQixJQUNBLEVBQUUsc0JBQVNGLG9CQUFvQkUsVUFBN0IsS0FBNEMsc0JBQVNGLG9CQUFvQkUsVUFBN0IsQ0FBOUMsQ0FESixFQUM2RjtBQUMzRixXQUFPLElBQUlJLFNBQUosQ0FBYyx3Q0FBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNDLHlCQUFULENBQW1DQyxpQkFBbkMsRUFBc0Q7QUFDcEQsTUFBSUEsa0JBQWtCQyxJQUFsQixJQUNBLEVBQUVELGtCQUFrQkMsSUFBbEIsS0FBMkIsUUFBM0IsSUFBdUNELGtCQUFrQkMsSUFBbEIsS0FBMkIsUUFBcEUsQ0FESixFQUNtRjtBQUNqRixXQUFPLElBQUlILFNBQUosQ0FBYyx1Q0FBZCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFPLEtBQVA7QUFDRDs7SUFFb0JJLG1CO0FBQ25COzs7OztBQUtBLCtCQUFZQyxpQkFBWixFQUErQjtBQUFBOztBQUM3QixRQUFJLENBQUMsc0JBQVNBLGlCQUFULENBQUwsRUFBa0M7QUFDaEMsWUFBTSxJQUFJTCxTQUFKLENBQWMsZ0RBQWQsQ0FBTjtBQUNEOztBQUVELFNBQUtLLGlCQUFMLEdBQXlCQSxpQkFBekI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLGdCQUFNQyxNQUFOLENBQWE7QUFDeEJDLGVBQVM7QUFDUCxzQkFBYztBQURQO0FBRGUsS0FBYixDQUFiOztBQU1BakIsVUFBTSxjQUFOO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7bUNBTXNDO0FBQUE7O0FBQUEsVUFBekJrQixJQUF5Qix1RUFBbEIsZ0JBQWtCOztBQUNwQztBQUNBLGFBQU9DLFFBQVFDLE9BQVIsR0FBa0JDLElBQWxCLENBQXVCO0FBQUEsZUFBTUYsUUFBUUcsR0FBUixDQUFZLDBCQUN2QyxTQUR1Qyw4QkFFdkMsYUFGdUMsSUFBWixDQUFOO0FBQUEsT0FBdkIsRUFJTkQsSUFKTSxDQUlELGdCQUEyQjtBQUFBO0FBQUEsWUFBekJFLE9BQXlCO0FBQUEsWUFBaEJDLFVBQWdCOztBQUMvQixZQUFNQyxNQUFNRixTQUFaO0FBQ0FFLFlBQUlDLEdBQUosQ0FBUUYsV0FBV0csVUFBWCxDQUFzQixFQUFFQyxVQUFVLEtBQVosRUFBdEIsQ0FBUjtBQUNBSCxZQUFJSSxJQUFKLENBQVNYLElBQVQsRUFBZSxNQUFLWSxpQkFBTCxFQUFmOztBQUVBOUIsY0FBTSwyQkFBTixFQUFtQ2tCLElBQW5DOztBQUVBLGVBQU8sZUFBS2EsWUFBTCxDQUFrQk4sR0FBbEIsQ0FBUDtBQUNELE9BWk0sQ0FBUDtBQWFEOzs7MEJBRUtPLEksRUFBTTtBQUFBOztBQUNWLGFBQU8sS0FBS0QsWUFBTCxHQUNKVixJQURJLENBQ0M7QUFBQSxlQUFVLElBQUlGLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVhLE1BQVYsRUFBcUI7QUFDL0MsaUJBQUtDLE1BQUwsR0FBY0EsTUFBZDtBQUNBQSxpQkFBT0MsRUFBUCxDQUFVLE9BQVYsRUFBbUJGLE1BQW5CO0FBQ0FDLGlCQUFPRSxNQUFQLENBQWNKLElBQWQsRUFBb0I7QUFBQSxtQkFBTVosUUFBUWMsTUFBUixDQUFOO0FBQUEsV0FBcEI7QUFDQWxDLGdCQUFNLDJCQUFOLEVBQW1DZ0MsSUFBbkM7QUFDRCxTQUxlLENBQVY7QUFBQSxPQURELENBQVA7QUFPRDs7OzJCQUVNO0FBQUE7O0FBQ0wsYUFBTyxJQUFJYixPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVYSxNQUFWLEVBQXFCO0FBQ3RDLFlBQUksT0FBS0MsTUFBVCxFQUFpQjtBQUNmLGlCQUFLQSxNQUFMLENBQVlHLEtBQVosQ0FBa0IsVUFBQ0MsS0FBRCxFQUFXO0FBQzNCLG1CQUFPLE9BQUtKLE1BQVo7QUFDQSxnQkFBSUksS0FBSixFQUFXO0FBQ1RMLHFCQUFPSyxLQUFQO0FBQ0QsYUFGRCxNQUVPO0FBQ0xsQjtBQUNEO0FBQ0YsV0FQRDtBQVFELFNBVEQsTUFTTztBQUNMYSxpQkFBTyxJQUFJTSxLQUFKLENBQVUsZ0VBQVYsQ0FBUDtBQUNEO0FBQ0YsT0FiTSxDQUFQO0FBY0Q7Ozt3Q0FFbUI7QUFDbEIsYUFBTyxnREFBd0IsSUFBeEIsQ0FBUDtBQUNEOzs7MkJBRU1yQyxtQixFQUFxQnNDLFEsRUFBVTtBQUNwQyxVQUFNOUIsb0JBQW9CVCwwQkFBMEJDLG1CQUExQixDQUExQjs7QUFFQSxVQUFNb0MsUUFBUS9CLG9CQUFvQkcsaUJBQXBCLEtBQ1pELDBCQUEwQkMsaUJBQTFCLENBREY7QUFFQSxVQUFJNEIsS0FBSixFQUFXO0FBQ1R0QyxjQUFNLG9DQUFOLEVBQTRDc0MsTUFBTUcsT0FBbEQ7QUFDQSxjQUFNSCxLQUFOO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLSSxnQkFBTCxDQUFzQmhDLGlCQUF0QixFQUF5QzhCLFFBQXpDLENBQVA7QUFDRDs7OzRCQUVPdEMsbUIsRUFBcUJzQyxRLEVBQVU7QUFDckMsVUFBTUcscUJBQXFCMUMsMEJBQTBCQyxtQkFBMUIsQ0FBM0I7O0FBRUEsVUFBTW9DLFFBQVEvQixvQkFBb0JvQyxrQkFBcEIsQ0FBZDtBQUNBLFVBQUlMLEtBQUosRUFBVztBQUNUdEMsY0FBTSxxQ0FBTixFQUE2Q3NDLE1BQU1HLE9BQW5EO0FBQ0EsY0FBTUgsS0FBTjtBQUNEOztBQUVELGFBQU8sS0FBS0ksZ0JBQUwsQ0FBc0JDLGtCQUF0QixFQUEwQ0gsUUFBMUMsQ0FBUDtBQUNEOztBQUVEOzs7O3FDQUVpQkksVyxFQUFhSixRLEVBQVU7QUFDdEM7QUFDQSxVQUFJLENBQUMsc0JBQVdBLFFBQVgsQ0FBTCxFQUEyQjtBQUN6QnhDLGNBQU0sc0RBQU47QUFDQSxjQUFNLElBQUlRLFNBQUosQ0FBYyw2QkFBZCxDQUFOO0FBQ0Q7O0FBRUQsV0FBS00sU0FBTCxDQUFlK0IsSUFBZixDQUFvQixDQUFDRCxXQUFELEVBQWNKLFFBQWQsQ0FBcEI7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7Ozs2QkFFUU0sTyxFQUFTO0FBQUE7O0FBQ2hCLFVBQU1DLFNBQVNELFFBQVFFLE9BQVIsSUFBbUJGLFFBQVFFLE9BQVIsQ0FBZ0IsQ0FBaEIsQ0FBbEM7O0FBRUE7QUFDQSxVQUFJQyxTQUFTLEVBQUVDLFFBQVEsR0FBVixFQUFiO0FBQ0E7QUFDQSxVQUFJQyw2QkFBSjtBQUNBLFVBQU1DLFVBQVUsU0FBVkEsT0FBVSxDQUFDWCxPQUFELEVBQWE7QUFDM0IsWUFBSUssUUFBUU8sWUFBWixFQUEwQjtBQUN4QnJELGdCQUFNLHdCQUFOO0FBQ0EsaUJBQU8sT0FBS2UsS0FBTCxDQUFXYyxJQUFYLENBQWdCaUIsUUFBUU8sWUFBeEIsRUFBc0NaLE9BQXRDLENBQVA7QUFDRCxTQUhELE1BR08sSUFBSVUsb0JBQUosRUFBMEI7QUFDL0JBLCtCQUFxQlYsT0FBckI7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNELE9BUkQ7O0FBVUEsV0FBSzNCLFNBQUwsQ0FBZXdDLElBQWYsQ0FBb0IsaUJBQXVCO0FBQUE7QUFBQSxZQUFyQlYsV0FBcUI7QUFBQSxZQUFSVyxFQUFROztBQUN6QztBQUNBO0FBQ0E7QUFDQSxZQUFJQyx1QkFBSjs7QUFFQSxZQUFJWixZQUFZeEMsVUFBaEIsRUFBNEI7QUFDMUIsY0FBSSxzQkFBU3dDLFlBQVl4QyxVQUFyQixLQUFvQzBDLFFBQVFXLFdBQVIsS0FBd0JiLFlBQVl4QyxVQUE1RSxFQUF3RjtBQUN0RixtQkFBTyxLQUFQO0FBQ0Q7QUFDRCxjQUFJLHNCQUFTd0MsWUFBWXhDLFVBQXJCLEtBQW9DLENBQUN3QyxZQUFZeEMsVUFBWixDQUF1QnNELElBQXZCLENBQTRCWixRQUFRVyxXQUFwQyxDQUF6QyxFQUEyRjtBQUN6RixtQkFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJVixVQUFVSCxZQUFZakMsSUFBdEIsSUFBOEJpQyxZQUFZakMsSUFBWixLQUFxQm9DLE9BQU9wQyxJQUE5RCxFQUFvRTtBQUNsRSxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsWUFBSSxZQUFZaUMsV0FBWixLQUVJQSxZQUFZZSxNQUFaLElBQXNCLENBQUNiLFFBQVFjLGFBQWhDLElBQ0MsQ0FBQ2hCLFlBQVllLE1BQWIsSUFBdUJiLFFBQVFjLGFBSG5DLENBQUosRUFLSztBQUNILGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxZQUFJO0FBQ0ZKLDJCQUFpQkQsR0FBR00sSUFBSCxTQUFjZixPQUFkLEVBQXVCTSxPQUF2QixDQUFqQjtBQUNELFNBRkQsQ0FFRSxPQUFPZCxLQUFQLEVBQWM7QUFDZHRDLGdCQUFNLG9CQUFOLEVBQTRCc0MsS0FBNUI7QUFDQVcsbUJBQVMsRUFBRUMsUUFBUSxHQUFWLEVBQVQ7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFlBQUlKLFFBQVFuQyxJQUFSLEtBQWlCLG1CQUFyQixFQUEwQztBQUN4QyxjQUFNbUQsS0FBSyxJQUFYO0FBQ0EsY0FBSU4sY0FBSixFQUFvQjtBQUNsQlAscUJBQVMsRUFBRUMsUUFBUSxHQUFWLEVBQWVhLFNBQVMsMEJBQWVELEVBQWYsRUFBbUJOLGNBQW5CLENBQXhCLEVBQVQ7QUFDRCxXQUZELE1BRU87QUFDTFAscUJBQVM7QUFDUEMsc0JBQVEsR0FERCxFQUNNYSxTQUFTLElBQUk1QyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFhO0FBQUUrQix1Q0FBdUIvQixPQUF2QjtBQUFpQyxlQUE1RDtBQURmLGFBQVQ7QUFHRDtBQUNELGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFJb0MsY0FBSixFQUFvQjtBQUNsQjtBQUNBLGNBQUksT0FBT0EsZUFBZW5DLElBQXRCLEtBQStCLFVBQW5DLEVBQStDO0FBQzdDbUMsMkJBQWVuQyxJQUFmLENBQW9CK0IsT0FBcEIsRUFBNkJZLEtBQTdCLENBQW1DLFVBQUMxQixLQUFELEVBQVc7QUFDNUN0QyxvQkFBTSxzREFBTixFQUNNOEMsUUFBUVcsV0FEZCxFQUMyQm5CLE1BQU1HLE9BRGpDO0FBRUQsYUFIRDtBQUlBLG1CQUFPLElBQVA7QUFDRDtBQUNEUSxtQkFBUyxFQUFFQyxRQUFRLEdBQVYsRUFBZWEsU0FBU1AsY0FBeEIsRUFBVDtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNELE9BL0REOztBQWlFQSxhQUFPUCxNQUFQO0FBQ0Q7Ozs7OztrQkF0TWtCckMsbUIiLCJmaWxlIjoiYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICdsb2Rhc2guaXNzdHJpbmcnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLmlzcGxhaW5vYmplY3QnO1xuaW1wb3J0IGlzUmVnRXhwIGZyb20gJ2xvZGFzaC5pc3JlZ2V4cCc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICdsb2Rhc2guaXNmdW5jdGlvbic7XG5pbXBvcnQgZGVidWdGYWN0b3J5IGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IGNyZWF0ZUV4cHJlc3NNaWRkbGV3YXJlIH0gZnJvbSAnLi9leHByZXNzLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgcGFja2FnZUlkZW50aWZpZXIsIHByb21pc2VUaW1lb3V0IH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ0BzbGFjay9pbnRlcmFjdGl2ZS1tZXNzYWdlczphZGFwdGVyJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB2YXJpb3VzIGZvcm1zIG9mIG1hdGNoaW5nIGNvbnN0cmFpbnRzIHRvIGEgc2luZ2xlIHN0YW5kYXJkIG9iamVjdCBzaGFwZVxuICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfE9iamVjdH0gbWF0Y2hpbmdDb25zdHJhaW50cyAtIHRoZSB2YXJpb3VzIGZvcm1zIG9mIG1hdGNoaW5nIGNvbnN0cmFpbnRzXG4gKiBhY2NlcHRlZFxuICogQHJldHVybnMge09iamVjdH0gLSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBtYXRjaGluZyBjb25zdHJhaW50IGlzIGEgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyhtYXRjaGluZ0NvbnN0cmFpbnRzKSB7XG4gIGxldCByZXQgPSB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG1hdGNoaW5nQ29uc3RyYWludHMpKSB7XG4gICAgcmV0LmNhbGxiYWNrSWQgPSBtYXRjaGluZ0NvbnN0cmFpbnRzO1xuICB9IGVsc2Uge1xuICAgIHJldCA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoaW5nQ29uc3RyYWludHMpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGdlbmVyYWwgcHJvcGVydGllcyBvZiBhIG1hdGNoaW5nIGNvbnN0cmFpbnRzIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGNoaW5nQ29uc3RyYWludHMgLSBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29uc3RyYWludHMgb24gYSBjYWxsYmFja1xuICogQHJldHVybiB7RXJyb3J8ZmFsc2V9IC0gYSBmYWxzZSB2YWx1ZSByZXByZXNlbnRzIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiwgb3RoZXJ3aXNlIGFuIGVycm9yIHRvXG4gKiBkZXNjcmliZSB3aHkgdmFsaWRhdGlvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RyYWludHMobWF0Y2hpbmdDb25zdHJhaW50cykge1xuICBpZiAobWF0Y2hpbmdDb25zdHJhaW50cy5jYWxsYmFja0lkICYmXG4gICAgICAhKGlzU3RyaW5nKG1hdGNoaW5nQ29uc3RyYWludHMuY2FsbGJhY2tJZCkgfHwgaXNSZWdFeHAobWF0Y2hpbmdDb25zdHJhaW50cy5jYWxsYmFja0lkKSkpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2FsbGJhY2sgSUQgbXVzdCBiZSBhIHN0cmluZyBvciBSZWdFeHAnKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgcHJvcGVydGllcyBvZiBhIG1hdGNoaW5nIGNvbnN0cmFpbnRzIG9iamVjdCBzcGVjaWZpYyB0byByZWdpc3RlcmluZyBhbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGluZ0NvbnN0cmFpbnRzIC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnN0cmFpbnRzIG9uIGEgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Vycm9yfGZhbHNlfSAtIGEgZmFsc2UgdmFsdWUgcmVwcmVzZW50cyBzdWNjZXNzZnVsIHZhbGlkYXRpb24sIG90aGVyd2lzZSBhbiBlcnJvciB0b1xuICogZGVzY3JpYmUgd2h5IHZhbGlkYXRpb24gZmFpbGVkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFjdGlvbkNvbnN0cmFpbnRzKGFjdGlvbkNvbnN0cmFpbnRzKSB7XG4gIGlmIChhY3Rpb25Db25zdHJhaW50cy50eXBlICYmXG4gICAgICAhKGFjdGlvbkNvbnN0cmFpbnRzLnR5cGUgPT09ICdzZWxlY3QnIHx8IGFjdGlvbkNvbnN0cmFpbnRzLnR5cGUgPT09ICdidXR0b24nKSkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdUeXBlIG11c3QgYmUgXFwnc2VsZWN0XFwnIG9yIFxcJ2J1dHRvblxcJycpO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byB2YWxpZGF0ZSB1bmZ1cmwsIHdlJ2xsIGp1c3QgY29vZXJjZSBpdCB0byBhIGJvb2xlYW5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGFja01lc3NhZ2VBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UgYWRhcHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcmlmaWNhdGlvblRva2VuIC0gU2xhY2sgYXBwIHZlcmlmaWNhdGlvbiB0b2tlbiB1c2VkIHRvIGF1dGhlbnRpY2F0ZSByZXF1ZXN0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJpZmljYXRpb25Ub2tlbikge1xuICAgIGlmICghaXNTdHJpbmcodmVyaWZpY2F0aW9uVG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTbGFja01lc3NhZ2VBZGFwdGVyIG5lZWRzIGEgdmVyaWZpY2F0aW9uIHRva2VuJyk7XG4gICAgfVxuXG4gICAgdGhpcy52ZXJpZmljYXRpb25Ub2tlbiA9IHZlcmlmaWNhdGlvblRva2VuO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5heGlvcyA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdVc2VyLUFnZW50JzogcGFja2FnZUlkZW50aWZpZXIoKSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBkZWJ1ZygnaW5zdGFudGlhdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2VydmVyIHRoYXQncyByZWFkeSB0byBzZXJ2ZSByZXF1ZXN0cyBmcm9tIFNsYWNrJ3MgaW50ZXJhY3RpdmUgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aD0vc2xhY2svYWN0aW9uc10gLSBUaGUgcGF0aCBwb3J0aW9uIG9mIHRoZSBVUkwgd2hlcmUgdGhlIHNlcnZlciB3aWxsXG4gICAqIGxpc3RlbiBmb3IgcmVxdWVzdHMgZnJvbSBTbGFjaydzIGludGVyYWN0aXZlIG1lc3NhZ2VzLlxuICAgKi9cbiAgY3JlYXRlU2VydmVyKHBhdGggPSAnL3NsYWNrL2FjdGlvbnMnKSB7XG4gICAgLy8gVE9ETzogbW9yZSBvcHRpb25zIChsaWtlIGh0dHBzKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IFByb21pc2UuYWxsKFtcbiAgICAgIGltcG9ydCgnZXhwcmVzcycpLFxuICAgICAgaW1wb3J0KCdib2R5LXBhcnNlcicpLFxuICAgIF0pKVxuICAgIC50aGVuKChbZXhwcmVzcywgYm9keVBhcnNlcl0pID0+IHtcbiAgICAgIGNvbnN0IGFwcCA9IGV4cHJlc3MoKTtcbiAgICAgIGFwcC51c2UoYm9keVBhcnNlci51cmxlbmNvZGVkKHsgZXh0ZW5kZWQ6IGZhbHNlIH0pKTtcbiAgICAgIGFwcC5wb3N0KHBhdGgsIHRoaXMuZXhwcmVzc01pZGRsZXdhcmUoKSk7XG5cbiAgICAgIGRlYnVnKCdzZXJ2ZXIgY3JlYXRlZCAtIHBhdGg6ICVzJywgcGF0aCk7XG5cbiAgICAgIHJldHVybiBodHRwLmNyZWF0ZVNlcnZlcihhcHApO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhcnQocG9ydCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVNlcnZlcigpXG4gICAgICAudGhlbihzZXJ2ZXIgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgc2VydmVyLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHNlcnZlci5saXN0ZW4ocG9ydCwgKCkgPT4gcmVzb2x2ZShzZXJ2ZXIpKTtcbiAgICAgICAgZGVidWcoJ3NlcnZlciBzdGFydGVkIC0gcG9ydDogJXMnLCBwb3J0KTtcbiAgICAgIH0pKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICB0aGlzLnNlcnZlci5jbG9zZSgoZXJyb3IpID0+IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zZXJ2ZXI7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NsYWNrTWVzc2FnZUFkYXB0ZXIgY2Fubm90IHN0b3Agd2hlbiBpdCBkaWQgbm90IHN0YXJ0IGEgc2VydmVyJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZXhwcmVzc01pZGRsZXdhcmUoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUV4cHJlc3NNaWRkbGV3YXJlKHRoaXMpO1xuICB9XG5cbiAgYWN0aW9uKG1hdGNoaW5nQ29uc3RyYWludHMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYWN0aW9uQ29uc3RyYWludHMgPSBmb3JtYXRNYXRjaGluZ0NvbnN0cmFpbnRzKG1hdGNoaW5nQ29uc3RyYWludHMpO1xuXG4gICAgY29uc3QgZXJyb3IgPSB2YWxpZGF0ZUNvbnN0cmFpbnRzKGFjdGlvbkNvbnN0cmFpbnRzKSB8fFxuICAgICAgdmFsaWRhdGVBY3Rpb25Db25zdHJhaW50cyhhY3Rpb25Db25zdHJhaW50cyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBkZWJ1ZygnYWN0aW9uIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkOiAlcycsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJDYWxsYmFjayhhY3Rpb25Db25zdHJhaW50cywgY2FsbGJhY2spO1xuICB9XG5cbiAgb3B0aW9ucyhtYXRjaGluZ0NvbnN0cmFpbnRzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG9wdGlvbnNDb25zdHJhaW50cyA9IGZvcm1hdE1hdGNoaW5nQ29uc3RyYWludHMobWF0Y2hpbmdDb25zdHJhaW50cyk7XG5cbiAgICBjb25zdCBlcnJvciA9IHZhbGlkYXRlQ29uc3RyYWludHMob3B0aW9uc0NvbnN0cmFpbnRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKCdvcHRpb25zIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkOiAlcycsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJDYWxsYmFjayhvcHRpb25zQ29uc3RyYWludHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qIEBwcml2YXRlICovXG5cbiAgcmVnaXN0ZXJDYWxsYmFjayhjb25zdHJhaW50cywgY2FsbGJhY2spIHtcbiAgICAvLyBWYWxpZGF0aW9uXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgZGVidWcoJ2RpZCBub3QgcmVnaXN0ZXIgY2FsbGJhY2sgYmVjYXVzZSBpdHMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goW2NvbnN0cmFpbnRzLCBjYWxsYmFja10pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXNwYXRjaChwYXlsb2FkKSB7XG4gICAgY29uc3QgYWN0aW9uID0gcGF5bG9hZC5hY3Rpb25zICYmIHBheWxvYWQuYWN0aW9uc1swXTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVzdWx0IHZhbHVlIHJlcHJlc2VudHMgXCJubyByZXBsYWNlbWVudFwiXG4gICAgbGV0IHJlc3VsdCA9IHsgc3RhdHVzOiAyMDAgfTtcbiAgICAvLyB3aGVuIHRoZSBtYXRjaGVyIGZpbmRzIGEgZGlhbG9nIHN1Ym1pc3Npb24sIGl0IHdpbGwgcG9wdWxhdGUgdGhpcyB2YWx1ZSB3aXRoIGEgZnVuY3Rpb25cbiAgICBsZXQgZGlhbG9nUHJvbWlzZVJlc29sdmU7XG4gICAgY29uc3QgcmVzcG9uZCA9IChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAocGF5bG9hZC5yZXNwb25zZV91cmwpIHtcbiAgICAgICAgZGVidWcoJ3NlbmRpbmcgYXN5bmMgcmVzcG9uc2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpb3MucG9zdChwYXlsb2FkLnJlc3BvbnNlX3VybCwgbWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKGRpYWxvZ1Byb21pc2VSZXNvbHZlKSB7XG4gICAgICAgIGRpYWxvZ1Byb21pc2VSZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMuY2FsbGJhY2tzLnNvbWUoKFtjb25zdHJhaW50cywgZm5dKSA9PiB7XG4gICAgICAvLyBSZXR1cm5pbmcgZmFsc2UgaW4gdGhpcyBmdW5jdGlvbiBjb250aW51ZXMgdGhlIGl0ZXJhdGlvbiwgYW5kIHJldHVybmluZyB0cnVlIGVuZHMgaXQuXG4gICAgICAvLyBUaGUgcGF0dGVybiBpcyB0aGF0IHdlIGFzc2lnbiBhIHZhbHVlIHRvIGByZXN1bHRgIGFuZCB0aGVuIHJldHVybiB0cnVlLiBXZSBvbmx5IGRlc2lyZSBvbmVcbiAgICAgIC8vIHJlc3VsdCBmb3IgdGhlIHJlc3BvbnNlLlxuICAgICAgbGV0IGNhbGxiYWNrUmVzdWx0O1xuXG4gICAgICBpZiAoY29uc3RyYWludHMuY2FsbGJhY2tJZCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludHMuY2FsbGJhY2tJZCkgJiYgcGF5bG9hZC5jYWxsYmFja19pZCAhPT0gY29uc3RyYWludHMuY2FsbGJhY2tJZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdFeHAoY29uc3RyYWludHMuY2FsbGJhY2tJZCkgJiYgIWNvbnN0cmFpbnRzLmNhbGxiYWNrSWQudGVzdChwYXlsb2FkLmNhbGxiYWNrX2lkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uICYmIGNvbnN0cmFpbnRzLnR5cGUgJiYgY29uc3RyYWludHMudHlwZSAhPT0gYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3VuZnVybCcgaW4gY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgKFxuICAgICAgICAgICAgIChjb25zdHJhaW50cy51bmZ1cmwgJiYgIXBheWxvYWQuaXNfYXBwX3VuZnVybCkgfHxcbiAgICAgICAgICAgICAoIWNvbnN0cmFpbnRzLnVuZnVybCAmJiBwYXlsb2FkLmlzX2FwcF91bmZ1cmwpXG4gICAgICAgICAgIClcbiAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrUmVzdWx0ID0gZm4uY2FsbCh0aGlzLCBwYXlsb2FkLCByZXNwb25kKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlYnVnKCdjYWxsYmFjayBlcnJvcjogJW8nLCBlcnJvcik7XG4gICAgICAgIHJlc3VsdCA9IHsgc3RhdHVzOiA1MDAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIERpYWxvZyBzdWJtaXNzaW9ucyBtdXN0IGJlIHJlc3BvbmRlZCB0byBpbiB1bmRlciAzIHNlY29uZHNcbiAgICAgIC8vIFNldHRpbmcgdGltZW91dCB0byAgMi41IHNlY29uZHMgdG8gYWNjb3VudCBmb3IgcHJvcGFnYXRpb25cbiAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdkaWFsb2dfc3VibWlzc2lvbicpIHtcbiAgICAgICAgY29uc3QgbXMgPSAyNTAwO1xuICAgICAgICBpZiAoY2FsbGJhY2tSZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB7IHN0YXR1czogMjAwLCBjb250ZW50OiBwcm9taXNlVGltZW91dChtcywgY2FsbGJhY2tSZXN1bHQpIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RhdHVzOiAyMDAsIGNvbnRlbnQ6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7IGRpYWxvZ1Byb21pc2VSZXNvbHZlID0gcmVzb2x2ZTsgfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrUmVzdWx0KSB7XG4gICAgICAgIC8vIENoZWNraW5nIGZvciBQcm9taXNlIHR5cGVcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja1Jlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2tSZXN1bHQudGhlbihyZXNwb25kKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKCdhc3luYyBlcnJvciBmb3IgY2FsbGJhY2suIGNhbGxiYWNrX2lkOiAlcywgZXJyb3I6ICVzJyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2tfaWQsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHsgc3RhdHVzOiAyMDAsIGNvbnRlbnQ6IGNhbGxiYWNrUmVzdWx0IH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=
//# sourceMappingURL=adapter.js.map